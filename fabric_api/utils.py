from __future__ import annotations

"""fabric_api.utils

Pure helper functions that mirror common AL logic and are reused across
client, extract and transform layers.  All helpers are deliberately side‑
effect‑free so they can be unit‑tested in isolation.

Coding conventions
------------------
* No external dependencies – only the stdlib and internal modules.
* Typing uses builtin collections (dict, list) and | None syntax instead of
  `typing.Optional` / `typing.Union` imports.
* Helper names closely follow their AL counterparts but with Pythonic snake‑
  case.
"""

from datetime import date, datetime
from typing import Any

# Local import is safe because client has no runtime dependency on utils
from .client import ConnectWiseClient  # noqa: WPS433  (allowed inside package)

###############################################################################
# Agreement helpers
###############################################################################

def is_timapottur_agreement(agreement_type: str) -> bool:  # noqa: D401
    """Return *True* when *agreement_type* is exactly ``"Tímapottur"``.

    Mirrors the AL function **CheckIfAgreementIsTimapottur**.
    Whitespace is stripped but case is **not** normalised – behaviour matches
    the legacy implementation where type names are case‑sensitive.
    """

    return agreement_type.strip() == "Tímapottur"


def get_parent_agreement_data(
    client: ConnectWiseClient,
    agreement_id: int,
) -> tuple[int, str]:  # noqa: D401
    """Return ``(parent_agreement_id, agreement_type_name)`` for *agreement_id*.

    If the agreement has no parent, the *parent_agreement_id* will be ``0``.
    Internally performs **one** GET request to
    ``/finance/agreements/{agreement_id}`` and extracts the relevant fields –
    this mirrors AL **GetParentAgreementIdAndType**.
    """

    if not agreement_id:
        return 0, ""

    agreement: dict[str, Any] = client.get(f"/finance/agreements/{agreement_id}").json()

    parent_id: int = agreement.get("parentAgreement", {}).get("id", 0) or 0
    agreement_type: str = get_nested_value(agreement, "type.name", "")

    return parent_id, agreement_type

###############################################################################
# Value conversions
###############################################################################

def convert_vat_to_percent(vat_decimal: float | int | None) -> float:  # noqa: D401
    """Convert decimal VAT (e.g. ``0.245``) to a percentage (``24.5``).

    Accepts *None* and returns *0.0* to keep pipeline logic simple.
    Mirrors AL **ConvertVATToProcent** behaviour.
    """

    if vat_decimal is None:
        return 0.0

    return float(vat_decimal) * 100

###############################################################################
# Misc generic helpers – frequently used across layers
###############################################################################

def get_nested_value(data: dict[str, Any] | list[Any] | None, dotted_path: str, default: Any = None) -> Any:  # noqa: E501
    """Safely retrieve *dotted_path* (e.g. ``"member.identifier"``) from *data*.

    Works with dictionaries and lists; numeric path segments are interpreted
    as list indices.  Returns *default* when traversal fails at any step.
    """

    if data is None:
        return default

    current: Any = data
    for segment in dotted_path.split("."):
        if isinstance(current, dict):
            current = current.get(segment, default)
        elif isinstance(current, list):
            try:
                index = int(segment)
                current = current[index]
            except (ValueError, IndexError):
                return default
        else:
            return default
    return current


def create_batch_identifier(ts: datetime | None = None) -> str:  # noqa: D401
    """Return UTC timestamp formatted as ``YYYYMMDD-HHMMSS``.

    Matches the batch identifier style generated by the AL integration.
    The optional *ts* parameter eases testing.
    """

    ts = ts or datetime.utcnow()
    return ts.strftime("%Y%m%d-%H%M%S")


def get_first_day_next_month(ref: date | None = None) -> str:  # noqa: D401
    """Return ISO string for the first day of the month following *ref* (UTC)."""

    ref = ref or date.today()
    year = ref.year + (1 if ref.month == 12 else 0)
    month = 1 if ref.month == 12 else ref.month + 1
    return date(year, month, 1).isoformat()

###############################################################################
# Public re‑exports
###############################################################################

__all__: list[str] = [
    "is_timapottur_agreement",
    "get_parent_agreement_data",
    "convert_vat_to_percent",
    "get_nested_value",
    "create_batch_identifier",
    "get_first_day_next_month",
]
