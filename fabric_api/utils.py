from __future__ import annotations

"""fabric_api.utils

Pure helper functions that mirror common AL logic and are reused across
client, extract and transform layers.  All helpers are deliberately side‑
effect‑free so they can be unit‑tested in isolation.

Coding conventions
------------------
* No external dependencies – only the stdlib and internal modules.
* Typing uses builtin collections (dict, list) and | None syntax instead of
  `typing.Optional` / `typing.Union` imports.
* Helper names closely follow their AL counterparts but with Pythonic snake‑
  case.
"""

from datetime import date, datetime
from typing import Any, TYPE_CHECKING

# Use TYPE_CHECKING to avoid circular imports
if TYPE_CHECKING:
    from .client import ConnectWiseClient

###############################################################################
# Agreement helpers
###############################################################################

def is_timapottur_agreement(agreement_type: str) -> bool:  # noqa: D401
    """Return *True* when *agreement_type* is exactly ``"Tímapottur"``.

    Mirrors the AL function **CheckIfAgreementIsTimapottur**.
    Whitespace is stripped but case is **not** normalised – behaviour matches
    the legacy implementation where type names are case‑sensitive.
    """

    return agreement_type.strip() == "Tímapottur"


def get_parent_agreement_data(
    client: "ConnectWiseClient",
    agreement_id: int,
) -> tuple[int, str]:  # noqa: D401
    """Return ``(parent_agreement_id, agreement_type_name)`` for *agreement_id*.

    If the agreement has no parent, the *parent_agreement_id* will be ``0``.
    Uses the cached agreement data if available, otherwise falls back to a direct API call.
    This mirrors AL **GetParentAgreementIdAndType**.
    """

    if not agreement_id:
        return 0, ""

    agreement_data: dict[str, Any] = {}
    
    try:
        # First try to use the cached version
        from .extract.agreements import get_cached_agreement
        
        cached_agreement = get_cached_agreement(client, agreement_id)
        
        if cached_agreement:
            agreement_data = cached_agreement
        else:
            # Fall back to the direct API call if not in cache
            response = client.get(endpoint=f"/finance/agreements/{agreement_id}")
            agreement_data = response.json()
    except ImportError:
        # Fall back to the direct API call if module not available
        response = client.get(endpoint=f"/finance/agreements/{agreement_id}")
        agreement_data = response.json()

    parent_id: int = agreement_data.get("parentAgreement", {}).get("id", 0) or 0
    agreement_type: str = get_nested_value(data=agreement_data, dotted_path="type.name", default="")

    return parent_id, agreement_type

###############################################################################
# Value conversions
###############################################################################

def convert_vat_to_percent(vat_decimal: float | int | None) -> float:  # noqa: D401
    """Convert decimal VAT (e.g. ``0.245``) to a percentage (``24.5``).

    Accepts *None* and returns *0.0* to keep pipeline logic simple.
    Mirrors AL **ConvertVATToProcent** behaviour.
    """

    if vat_decimal is None:
        return 0.0

    return float(vat_decimal) * 100

###############################################################################
# Misc generic helpers – frequently used across layers
###############################################################################

def get_nested_value(data: dict[str, Any] | list[Any] | None, dotted_path: str, default: Any = None) -> Any:  # noqa: E501
    """Safely retrieve *dotted_path* (e.g. ``"member.identifier"``) from *data*.

    Works with dictionaries and lists; numeric path segments are interpreted
    as list indices.  Returns *default* when traversal fails at any step.
    """

    if data is None:
        return default

    current_value: Any = data
    for segment in dotted_path.split(sep="."):
        if isinstance(current_value, dict):
            current_value = current_value.get(segment, default)
        elif isinstance(current_value, list):
            try:
                index: int = int(segment)
                current_value = current_value[index]
            except (ValueError, IndexError):
                return default
        else:
            return default
    return current_value


def create_batch_identifier(timestamp: datetime | None = None) -> str:  # noqa: D401
    """Return UTC timestamp formatted as ``YYYYMMDD-HHMMSS``.

    Matches the batch identifier style generated by the AL integration.
    The optional *timestamp* parameter eases testing.
    """

    ts: datetime = timestamp or datetime.utcnow()
    return ts.strftime("%Y%m%d-%H%M%S")


def get_first_day_next_month(reference: date | None = None) -> str:  # noqa: D401
    """Return ISO string for the first day of the month following *reference* (UTC)."""

    ref: date = reference or date.today()
    year: int = ref.year + (1 if ref.month == 12 else 0)
    month: int = 1 if ref.month == 12 else ref.month + 1
    return date(year, month, day=1).isoformat()

###############################################################################
# Public re‑exports
###############################################################################

__all__: list[str] = [
    "is_timapottur_agreement",
    "get_parent_agreement_data",
    "convert_vat_to_percent",
    "get_nested_value",
    "create_batch_identifier",
    "get_first_day_next_month",
]
